import { MAX_TASK_TEXT_LENGTH, STATUS, Status } from './constants';
import { parseDate, printDate } from './utils';

export interface BaseTask {
    task_id?: string,
    task_text?: string,
    estimated_end_at?: string,
    file_id?: string
}

// Task, received from DB or generated by backend 
export interface RawTask extends BaseTask {
    task_status?: string,
    created_at?: string
}

// Task, formatted for presentation on client
export interface OutputTask extends BaseTask {
    task_status?: Status,
    deadline?: boolean
}

// Task, received from client
export interface InputTask extends BaseTask {
    task_status?: string,
    att_file?: {
        file: any,
        filename: string,
    }
}

export interface ValidationError {
    text_short?: boolean,
    text_long?: boolean,
    estimated_end_at?: boolean,
    status_present?: boolean
}

export interface ValidatedTask {
    task: InputTask,
    errors: ValidationError | undefined
}

export class Model {
    tasks: Array<OutputTask>;
    errors: ValidationError;

    constructor(tasks: Array<OutputTask> = [], 
                errors?: ValidationError) {

        this.tasks = tasks;
        this.errors = errors;
    }

    static createTask(value: RawTask | InputTask = {}): OutputTask {
        return {
            task_id: value.task_id,
            task_text: value.task_text ?? '',
            task_status: STATUS[value.task_status] ?? STATUS.OPENED,
            estimated_end_at: value.estimated_end_at ? printDate(new Date(value.estimated_end_at)) : '',
            deadline: value.estimated_end_at ? (new Date() >= new Date(value.estimated_end_at)) : false,
            file_id: value.file_id ?? ''
        };
    }

    static validateTask(task: InputTask): ValidatedTask {
        
        const validTask: InputTask = {
            task_text: task.task_text ?? '',
            task_status: task.task_status ? STATUS[task.task_status]?.value : null,
            estimated_end_at: parseDate(task.estimated_end_at),
            file_id: task.file_id
        };

        const errors = {
            text_short: validTask.task_text.length < 1,
            text_long: validTask.task_text?.length >= MAX_TASK_TEXT_LENGTH,
            estimated_end_at: !validTask.estimated_end_at,
            status_present: !validTask.task_status
        };

        const errorPresent = errors.text_short || errors.text_long || errors.estimated_end_at || errors.status_present;

        return {
            task: validTask,
            errors: errorPresent ? errors : undefined
        };
    }
}